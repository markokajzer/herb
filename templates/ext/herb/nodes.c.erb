#include <ruby.h>

#include "error_helpers.h"
#include "extension_helpers.h"
#include "extension.h"
#include "nodes.h"

#include "../../src/include/herb.h"
#include "../../src/include/token.h"

VALUE rb_node_from_c_struct(AST_NODE_T* node);
static VALUE rb_nodes_array_from_c_array(hb_array_T* array);

static VALUE mAST;
static VALUE cNode;
<%- nodes.each do |node| -%>
static VALUE c<%= node.name %>;
<%- end -%>

void rb_init_node_classes(void) {
  mAST = rb_define_module_under(mHerb, "AST");
  cNode = rb_define_class_under(mAST, "Node", rb_cObject);
  <%- nodes.each do |node| -%>
  c<%= node.name %> = rb_define_class_under(mAST, "<%= node.name %>", cNode);
  <%- end -%>
}

<%- nodes.each do |node| -%>
static VALUE rb_<%= node.human %>_from_c_struct(<%= node.struct_type %>* <%= node.human %>) {
  if (<%= node.human %> == NULL) { return Qnil; }

  AST_NODE_T* node = &<%= node.human %>->base;

  hb_string_T node_type = ast_node_type_to_string(node);
  VALUE type = rb_utf8_str_new(node_type.data, node_type.length);
  VALUE location = rb_location_from_c_struct(node->location);
  VALUE errors = rb_errors_array_from_c_array(node->errors);

  <%- node.fields.each do |field| -%>
  <%- case field -%>
  <%- when Herb::Template::StringField -%>
  VALUE <%= node.human %>_<%= field.name %> = rb_utf8_str_new_cstr(<%= node.human %>-><%= field.name %>);
  <%- when Herb::Template::NodeField, Herb::Template::BorrowedNodeField -%>
  VALUE <%= node.human %>_<%= field.name %> = rb_node_from_c_struct((AST_NODE_T*) <%= node.human %>-><%= field.name %>);
  <%- when Herb::Template::TokenField -%>
  VALUE <%= node.human %>_<%= field.name %> = rb_token_from_c_struct(<%= node.human %>-><%= field.name %>);
  <%- when Herb::Template::BooleanField -%>
  VALUE <%= node.human %>_<%= field.name %> = (<%= node.human %>-><%= field.name %>) ? Qtrue : Qfalse;
  <%- when Herb::Template::ArrayField -%>
  VALUE <%= node.human %>_<%= field.name %> = rb_nodes_array_from_c_array(<%= node.human %>-><%= field.name %>);
  <%- when Herb::Template::ElementSourceField -%>
  VALUE <%= node.human %>_<%= field.name %>;
  {
    hb_string_T element_source_string = element_source_to_string(<%= node.human %>-><%= field.name %>);
    <%= node.human %>_<%= field.name %> = rb_utf8_str_new(element_source_string.data, element_source_string.length);
  }
  <%- when Herb::Template::LocationField -%>
  VALUE <%= node.human %>_<%= field.name %> = (<%= node.human %>-><%= field.name %> != NULL) ? rb_location_from_c_struct(*<%= node.human %>-><%= field.name %>) : Qnil;
  <%- when Herb::Template::AnalyzedRubyField, Herb::Template::PrismNodeField, Herb::Template::VoidPointerField -%>
  /* <%= field.name %> is internal parser state, not exposed to Ruby */
  VALUE <%= node.human %>_<%= field.name %> = Qnil;
  <%- else -%>
  /* Unhandled field type: <%= field.class.name %> */
  VALUE <%= node.human %>_<%= field.name %> = Qnil;
  <%- end -%>
  <%- end -%>

  VALUE args[<%= 3 + node.fields.count %>] = {
    type,
    location,
    errors<% if node.fields.any? %>,<% end %>
    <%- node.fields.each do |field| -%>
    <%= node.human %>_<%= field.name %><% if node.fields.last != field %>,<% end %>
    <%- end -%>
  };

  return rb_class_new_instance(<%= 3 + node.fields.count %>, args, c<%= node.name %>);
};

<%- end -%>

VALUE rb_node_from_c_struct(AST_NODE_T* node) {
  if (!node) { return Qnil; }

  switch (node->type) {
  <%- nodes.each do |node| -%>
    case <%= node.type %>: return rb_<%= node.human %>_from_c_struct((<%= node.struct_type %>*) node); break;
  <%- end -%>
  }

  return Qnil;
}

static VALUE rb_nodes_array_from_c_array(hb_array_T* array) {
  VALUE rb_array = rb_ary_new();

  if (array) {
    for (size_t i = 0; i < hb_array_size(array); i++) {
      AST_NODE_T* child_node = (AST_NODE_T*) hb_array_get(array, i);

      if (child_node) {
        VALUE rb_child = rb_node_from_c_struct(child_node);
        rb_ary_push(rb_array, rb_child);
      }
    }
  }

  return rb_array;
}
